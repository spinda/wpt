// Copied from the JS harness generated by the WebAssembly reference
// interpreter, and modified to make it asynchronous.
// See https://github.com/WebAssembly/spec/tree/master/interpreter
'use strict';

let spectest = {
  print: console.log.bind(console),
  print_i32: console.log.bind(console),
  print_i32_f32: console.log.bind(console),
  print_f64_f64: console.log.bind(console),
  print_f32: console.log.bind(console),
  print_f64: console.log.bind(console),
  global_i32: 666,
  global_f32: 666,
  global_f64: 666,
  table: new WebAssembly.Table({initial: 10, maximum: 20, element: 'anyfunc'}),
  memory: new WebAssembly.Memory({initial: 1, maximum: 2})
};
let handler = {
  get(target, prop) {
    return (prop in target) ?  target[prop] : {};
  }
};
let registry = new Proxy({spectest}, handler);

let counter = 0;
let test_name = x => `${x}_${counter++}`;

function promise_test_with_result(test_function, name, properties) {
  let resolve, reject;
  let result = new Promise((res, rej) => { resolve = res; reject = rej; });
  promise_test(t => {
    // Eat promise rejections, since they may be expected.
    return test_function(t).then(resolve, reject);
  }, name, properties);
  return result;
}

function register(name, instance) {
  promise_test(() => {
    return instance.then(inst => {
      registry[name] = inst.exports;
    });
  }, test_name('register'));
}

function module(bytes, valid = true) {
  return promise_test_with_result(() => {
    let buffer = new ArrayBuffer(bytes.length);
    let view = new Uint8Array(buffer);
    for (let i = 0; i < bytes.length; ++i) {
      view[i] = bytes.charCodeAt(i);
    }
    let validated;
    try {
      validated = WebAssembly.validate(buffer);
    } catch (e) {
      throw new Error("Wasm validate throws");
    }
    if (validated !== valid) {
      throw new Error("Wasm validate failure" + (valid ? "" : " expected"));
    }
    return WebAssembly.compile(buffer);
  }, test_name('module'));
}

function instance(bytes, imports = registry) {
  let mod = module(bytes);
  return promise_test_with_result(() => {
    return Promise.all([mod, Promise.resolve(imports)])
        .then(([m, imp]) => WebAssembly.instantiate(m, imp));
  }, test_name('instance'));
}

function call(instance, name, args) {
  return promise_test_with_result(() => {
    return instance.then(inst => {
      return inst.exports[name](...args);
    });
  }, test_name('call'));
}

function get(instance, name) {
  return promise_test_with_result(() => {
    return instance.then(inst => {
      let v = inst.exports[name];
      return (v instanceof WebAssembly.Global) ? v.value : v;
    });
  }, test_name('get'));
}

function exports(name, instance) {
  return promise_test_with_result(() => {
    return instance.then(inst => {
      return {[name]: inst.exports};
    });
  }, test_name('exports'));
}

function run(action) {
  let result = action();
  promise_test(t => result, test_name('run'));
}

function assert_malformed(bytes) {
  let mod = module(bytes, false);
  promise_test(t => {
    return promise_rejects(t, new WebAssembly.CompileError(), mod);
  }, test_name('assert_malformed'));
}

function assert_invalid(bytes) {
  let mod = module(bytes, false);
  promise_test(t => {
    return promise_rejects(t, new WebAssembly.CompileError(), mod);
  }, test_name('assert_malformed'));
}

function assert_unlinkable(bytes) {
  let inst = instance(bytes);
  promise_test(t => {
    return promise_rejects(t, new WebAssembly.LinkError(), inst);
  }, test_name("assert_unlinkable"));
}

function assert_uninstantiable(bytes) {
  let inst = instance(bytes);
  promise_test(t => {
    return promise_rejects(t, new WebAssembly.RuntimeError(), inst);
  }, test_name("assert_uninstantiable"));
}

function assert_trap(action) {
  let result = action();
  promise_test(t => {
    return promise_rejects(t, new WebAssembly.RuntimeError(), result);
  }, test_name("assert_trap"));
}

let StackOverflow;
try { (function f() { 1 + f() })() } catch (e) { StackOverflow = e.constructor }

function assert_exhaustion(action) {
  let result = action();
  promise_test(t => {
    return promise_rejects(t, new StackOverflow(), result);
  }, test_name("assert_exhaustion"));
}

function assert_return(action, expected) {
  let result = action();
  promise_test(() => {
    return result.then(actual => {
      assert_equals(actual, expected);
    });
  }, test_name("assert_return"));
}

function assert_return_canonical_nan(action) {
  let result = action();
  promise_test(() => {
    return result.then(actual => {
      // Note that JS can't reliably distinguish different NaN values,
      // so there's no good way to test that it's a canonical NaN.
      assert_equals(actual, NaN);
    });
  }, test_name("assert_return_canonical_nan"));
}

function assert_return_arithmetic_nan(action) {
  let result = action();
  promise_test(() => {
    return result.then(actual => {
      // Note that JS can't reliably distinguish different NaN values,
      // so there's no good way to test for specific bitpatterns here.
      assert_equals(actual, NaN);
    });
  }, test_name("assert_return_arithmetic_nan"));
}
